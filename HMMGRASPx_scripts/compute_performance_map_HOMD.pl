#!/usr/bin/perl -w
use strict;

# compute Recall/Precision of a given mapping file

# the sequences of genomes which are chosen for testing the performance
# the sequences from which the GroudTruth is defined
# expected to be /usr/local/projdata/0599/projects/SPA/czhong/Works/OralMeta/Data/HOMD/major_species.fna
my $ref_sequence = shift;

# the SAM file of the mapping of the sequencing reads
# primarily used to define a set of reads that can be mapped to one of the reference sequences
my $sam_file = shift;

# the ground-truth file defiend based on HMMER hmmsearch results
# the file is expected to have a format of the following: read_ID	gene_name
# for example: "SOLEXA4:46:C1NBHACXX:6:1101:11688:2073/2:N:0:ATCACG     formatted.TunD"
my $tp_file = shift;

# the mapping file, generated by HMM-GRASPx, or any with compatible file format
# for example: "16 SOLEXA4:46:C1NBHACXX:6:1101:4859:2242/1:N:0:ATCACG_1_101_+  contig_4662||formatted.MGT2|| 0  1"
my $recruit_file = shift;

##################################################################
# finished defining input arguments
##################################################################

# define the sample frame (the set of reads of interest)
my %genome_id;
open my $RIN, "<$ref_sequence" or die "Cannot open file: $!\n";
while(<$RIN>)  {
  if(/^>(\S+)/)  {
    $genome_id{$1} = 1;
  }
}
close $RIN;

my %reads_of_interest;
open my $SIN, "<$sam_file" or die "Cannot open file: $!\n";
while(<$SIN>)  {
  chomp;
  my @decom = split /\s+/, $_;
  $reads_of_interest{$decom[0]} = 1 if exists $genome_id{$decom[2]};
}
close $SIN;

# reads in ground-truth definition and prediction
my %ground_truth;
open my $GIN, "<$tp_file" or die "Cannot open file: $!\n";
while(<$GIN>)  {
  chomp;
  my @decom = split /\s+/, $_;
  $ground_truth{$decom[1]}{$decom[0]} = 1;
}
close $GIN;

my %predicted;
open my $PIN, "<$recruit_file" or die "Cannot open file: $!\n";
while(<$PIN>)  {
  chomp;
  my @decom = split /\s+/, $_;
  my @decom2 = split /\|\|/, $decom[2];
  my @decom3 = split /\_/, $decom[1];
  $predicted{$decom2[1]}{$decom3[0]} = 1 if exists $reads_of_interest{$decom3[0]};
}
close $PIN;

# compute TP/FP/FN and compute Recall/Precision
my $TP = 0;
my $FP = 0;
my $FN = 0;
foreach(keys %ground_truth)  {
  my $g_name = $_;
  if(!exists $predicted{$g_name})  {
    $FN += scalar keys %{$predicted{$g_name}};
  }  else  {
    foreach(keys %{$predicted{$g_name}})  {
      if(exists $ground_truth{$g_name}{$_})  {
        ++ $TP;
        delete $ground_truth{$g_name}{$_};
      }  else  {
        ++ $FP;
      }
    }
    $FN += scalar keys %{$ground_truth{$g_name}};
  }
}

#foreach(keys %ground_truth)  {
#  my $g_name = $_;
#  foreach(keys %{$ground_truth{$g_name}})  {
#    print "$g_name	$_\n";
#  }
#}
#foreach(keys %predicted)  {
#  my $g_name = $_;
#  foreach(keys %{$predicted{$g_name}})  {
#    print "$g_name      $_\n";
#  }
#}

#print "$TP	$FP	$FN\n";

my $recall = $TP / ($TP + $FN);
my $precision = $TP / ($TP + $FP);
print "#RECALL	PRECISION	TP	FP	FN\n";
print "$recall	$precision	$TP	$FP	$FN\n";
